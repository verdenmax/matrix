# 第三次作业

## 1.Distributing Candy Game

Modeling：

题目描述了 $n$ 个学生，每个学生左手边和右手边各有一个数字。
所有学生排在一行，每个学生获得的糖果数量等于他前面所有人的左手上的数字乘积除以他右手上的数字，下取整。
记第 $i$ 个同学左手数字为 $l[i]$，右手数字为 $r[i]$。

现在需要通过重新排序所有学生，最小化收到最多糖果数量。

现在可以考虑一个多步决策，第 $i$ 步决策出放那个同学在 $n - i + 1$ 的位置上。
如：第 $1$ 步决策，可以决策 $1 - n$ 这个 $n$ 个同学谁放在 $n$ 位置上。
第 $2$ 步决策，可以决策剩下的 $n-1$ 个同学谁放在 $n-1$ 位置上。

通过上面的决策，每个人放在最后一个位置后，就对之后的决策没有影响，每次的决策都可以看作选择谁作为当前最后一个位置。
假设第一步决策 $x$ 同学放在位置 $n$，那么接受到的糖果数量为 $\frac{\prod_j l[j]}{l[x] r[x]}$。
第二步决策 $y$ 同学放在位置 $n - 1$，那么接受到的糖果数量为 $\frac{\prod_j l[j]}{l[x] l[y] r[y]}$。


那么发现，$l[y] r[y] \le l[x] r[x]$，情况下，最优。
可以分情况进行交换，交换完后只会更差。

所以只需要对所有同学的 $l[x] \times r[x]$，然后从小到大进行排序即可。

Algorithm：

使用库函数中 $sort$ ，按每个同学 $l[x] \times r[x]$值从小到大进行排序。

这个顺序就是重排后最优的顺序之一。

通过这个顺序也可以进行计算出题目中收到糖果最多的同学收到的糖果数。

Time complexity：

由于需要对 $n$ 个同学进行排序，花费 $O(nlogn)$。

所以总时间复杂度为：$O(nlogn)$

Space complexity：

没有占用输入之外额外空间。所以空间复杂度为：$O(1)$。

## 2.Array Partition

Modeling：

题目给定一个包含 $2n$ 个整数的数组 $nums$，将这些整数分成 $n$ 对 $(a_1,b_1),(a_2,b_2),...,(a_n,b_n)$。让 $\sum_i min(a_i,b_i)$ 最大。最后返回这个最大的和。

对于一个最简单的情况，四个数 $x_1 > x_2 > x_3 > x_4$，在这种情况下，最优的解为 $(x_1,x_2),(x_3,x_4)$。

那么可以对题目中数组$nums$先进行排序，在排序后的数组中进行处理。根据上面的情况分析，可以得出每次选择都是选择和自己邻近的数。

Algorithm：

对 $nums$ 从小到大进行排序。

选定的组为 $(nums[0],nums[1]),(nums[2],nums[3]),....,(nums[2\times n-2],nums[2\times n-1])$。

这样最大的和为 $\sum_{0 \le i \le n - 1} nums[2 \times i]$

Time complexity：

其中排序时间复杂度为 $O(nlogn)$。

求解最大值只需要遍历一遍数组，所以是 $O(n)$。

总时间复杂度为：$O(nlogn)$。

Space complexity：

没有占用输入之外额外空间。所以空间复杂度为：$O(1)$。

## 3.Delete Number Game

Modeling：

题目给定一个长度为 $n$ 的非负整数 $x$，并且给一个整数 $k$。题目中可以对 $x$ 选择 $k$ 个位置删除，最后剩下的位置从左到右拼接成一个整数，现在需要找到一种删除数字的方法使得剩下的数字组成的新数字最小。

可以将题目转化为一个多步决策过程，共 $k$ 步决策，每次决策删除 $x$ 的那一个位置。
发现在最优决策中，每次决策都可以选择找到一个尽可能高位的 $i$，并且满足 $x[i] > x[i+1]$。

Algorithm：

进行 $k$ 次决策，每次决策从高位（左边）开始找，找到一个位置 $i$ 满足 $x[i] > x[i+1]$，则删除位置 $i$ 的数。

然后每次其实不需要从最高位开始找，因为每次删除 $i$ 位置，只新增 $x[i-1]，x[i+1]$ 这个邻近的关系，所以只需要从 $i-1$ 接着向下找即可。如果最后没有找到，删除最后一个位置即可。

Time complexity：

由于删除的时候最多会遍历一整遍 $x$，所以时间复杂度为： $O(n)$。

Space complexity：

没有占用输入之外额外空间。所以空间复杂度为：$O(1)$。

## 4.Container Balancing Operations

Modeling：

有 $n$ 个容器排成一排，每个容器中包含一定数量的物品。可以执行多次操作，使得所有容器中物品数量相同。

每次可以选择任意数量的容器，并移动一个物品到其相邻的容器中。

任务是计算出将所有容器物品数量相同的最小操作次数。


发现对于一个区域中，最大移动次数就等于当前还有多少累计未移动的。

所以可以先计算出平均值，如果是整数则最终可以移动到相同，否则不能。

Algorithm：

先对所有容器中物品数量进行求和，得到 $sum$。

$avg = \frac{sum}{n}$，计算出平均数，如果平均数是个整数则说明可以移动成功，否则不可以。

计算最小操作次数：

```c++
// 元素中每个位置减去平均值
for(int i = 0 ; i < n ; i ++) c[i] -= avg ;

int op = 0 ;  // 记录最小操作次数
int tot = 0 ;
for(int i = 0 ; i < n ; i ++) 
  tot += c[i],
  op = max(op,abs(tot)) ;
```

Time complexity：

只进行了线性操作，所以总时间复杂度为：$O(n)$。

Space complexity：

没有占用输入之外额外空间。所以空间复杂度为：$O(1)$。
