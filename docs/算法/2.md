# 第二次作业

## 1.Step Problem

Modeling：
题目描述了一个青蛙，每次可以跳 $1$ 步或者 $2$ 步。需要找到青蛙跳到第 $n$ 级台阶有多少种不同的方式。
题目输入是一个整数 $n$ ，输出是一个整数青蛙跳的不同方式个数。

对于青蛙在当前台阶来说，可以决策跳 $1$ 步或者跳 $2$ 步，所以这是一个多步决策过程。
其中目的是求解最终决策到第 $n$ 级台阶时的方案数，可以记 $f(n)$ 为解，那么可以通过决策来构造 $f(n) = f(n-1) + f(n-2)$。这样将原问题分解为了两个不相关的子问题。
这样可以使用DP算法求解。

Algorithm：

记 $f(n)$ 为跳到 $n$ 级台阶的方案数。
Modeling中已经推出状态转移 $f(n) = f(n-1) + f(n-2)$。
初始值 $f(1)=f(2)=1$。
使用上述状态转移递推求解出 $f(n)$ 即可。

Time complexity：

由于共有 $n$ 个状态，状态的转移只需要计算加法即 $O(1)$。

所以时间复杂度为：$O(n)$

Space complexity：

由于需要存储状态数组 $f[n]$。一共需要存储 $n$ 个状态。

所以空间复杂度为：$O(n)$

## 2.Buy

Modeling：

题目描述是有很多物品，每个物品有价格 $v_i$ 和重要等级 $w_i$ 两个属性。现在需要选出一些物品不超过预算的情况下总价值最大，总价值为所选物品的价格和重要等级乘积后求和。
即假如选择 $k$ 个物品，下标为 $j_1,j_2,...,j_k$ ，那么总价值为 $\sum_{1 \le i \le k} v_{j_i} \times w_{j_i}$

题目已经给出了需要选择一些物品，这个过程可以分解成多个决策。对于给出的每一个物品来说，决策是否选择。这样对所有物品的决策组成最后的结果。
对于本题目来说，是定义在预算下的总价值最大，那么可以定义预算为 $W$，那么定义需要求的答案为 $f(W)$ 解释为刚好总价值为 $f(W)$ 时总价值最大值。对于第 $i$ 个决策，决策选则该物品可以得到状态转移 $f(x) = f(x-v_i)^{old} + v_i * w_i$。
已经得到状态转移，并且分析出决策过程是什么，所以可以使用DP方法求解。

Algorithm：

记 $f(x)$ 为选的物品价格和为 $x$ 时的最大总价值。
Modeling 中已经推出状态转移，对于第 $i$ 个物品来说选择该物品 $f(x) = f(x-v_i)^{old} + v_i * w_i$，不选择该物品 $f(x) = f(x)^{old}$。
这里 $f(x)^{old}$ 是指上一个物品的决策状态。
那么使用递推即可，其实就是一个背包问题。

注意最终答案是遍历 $1..W$ 中所有 $f(x)$ 找到最大值。

Time complexity：

状态总数严格来说，共有 $n \times W$。每次转移 $O(1)$

所以时间复杂度为：$O(nW)$。其中 $n$ 为物品总数，$W$为预算。

Space complexity：

使用滚动数组优化后,

空间复杂度为：$O(W)$。$W$为预算。

## 3. Counting

Modeling：
题目先定义了一个数组存在一种方式分割方式使得每一部分的最小值等于该部分长度，这样的数组称为 $nice$。
题目会给出一个递增的集合 $S$，其中有 $m$ 个元素。需要从集合 $S$ 中取出元素构造一个长度为 $n$ 的数组，统计出可以构造为 $nice$ 数组的数目。

先分析出，对于一个数组来说，最重要的是分割后每一个部分的最小值。那么有了最小值就有了这个分割的每一部分。那么就不需要考虑整个数组了，构造的时候直接考虑每个数组是由一些最小值等于长度的片段拼成。
可以定义题目中求解值为 $f(x)$，长度为 $x$ 时 $nice$ 数组数目。那么对于长度为 $i$ 时，后面肯定紧跟一个最小值等于长度的片段，那么可以进行决策这个片段长度。
这个片段长度是集合 $S$ 中的一个元素，然后可以通过容斥计算出该长度片段方案数（也可预处理出来）。记决策长度为 $len$，该长度片段（不可再分）方案数为 $cnt$，那么状态转移为 $f(i+len) += f[i] * cnt$。

那么由状态转移，可以使用DP方法解决该问题。

Algorithm：

记 $f(x)$ 为从 $S$ 中构造出长度为 $x$ 的数组中 $nice$ 数量。
从小到大枚举长度，对于当前长度 $i$ 来说，枚举所有的不可再分的长度片段，即枚举集合 $S$中值作为该片段最小值和长度，并计算出该长度方案数。
记当前枚举的长度为 $len$，那么可以进行状态转移 $f(i+len) += f(i) * cnt$。

最终答案就是 $f(n)$。

Time complexity：

共有 $n$个状态，并且状态转移时需要枚举所有的集合元素作为最小值，即 $m$次。

所以时间复杂度为： $O(nm)$

Space complexity：

由于需要记录 $n$ 个状态，

所以时间复杂度为：$O(n)$

## 4.Ex. Buy! Buy! Buy!

Modeling：

本题和第二题一样，只不过多了物品之间的关系。一个主要物品是有多个配件。并且选择一个配件前提条件必须选择该配件对应的主要物品。
题目描述是有很多物品，每个物品有价格 $v_i$ 和重要等级 $w_i$ 两个属性。现在需要选出一些物品不超过预算的情况下总价值最大，总价值为所选物品的价格和重要等级乘积后求和。
即假如选择 $k$ 个物品，下标为 $j_1,j_2,...,j_k$ ，那么总价值为 $\sum_{1 \le i \le k} v_{j_i} \times w_{j_i}$。

题目已经给出了需要选择一些物品，这个过程可以分解成多个决策。对于给出的每一个物品来说，决策是否选择。这样对所有物品的决策组成最后的结果。这里将一个主要物品与它对应所有物品分为一个组。进行每一步决策直接决策该组整体内容。
对于一个组本身来说，在其内部，可以定义 $g(x)$ 为花费价格 $x$，得到的最大价值，并且是默认选择了主项的。对于一个组内部的解，由于已经固定选择主项，那么配件就可以自由选择或者不选择。那么每个决策可以定义为选择该配件或者不选择。
状态转移为 $g(x) = g(x-v_i)^{old} + v_i * w_i$。

求解出每个组的信息后，每个组都是一些点对，代表选择这些物品后花费 $x$，得到最大价值为 $g(x)$。那么对于总的解来说可以通过 $g(x)$ 来进行状态转移。
这里的 $g(x)$ 其实就是子问题的最优解。然后题目有多个这样的子问题，分别求解出后，使用类似的状态决策进行转移 $f(x)$ 即可。
已经得到状态转移，并且分析出决策过程是什么，所以可以使用DP方法求解。

Algorithm：

记 $f(x)$ 为选的物品价格和为 $x$ 时的最大总价值。
对所有物品按照主物品分成多个组。

对于其中一个组来说，可以使用 $g(x) = g(x-v_i)^{old} + v_i * w_i$ 来获得所有状态。
对于总体来说，遍历所有的组，对于每一个组来说使用 $i,g(i)$ 来更新 $f(x)$。

注意最终答案是遍历 $1..W$ 中所有 $f(x)$ 找到最大值。

Time complexity：

每个分组中的状态转移需要花费 $O(n)$。最坏是 $m$ 组。
所以时间复杂度为 $O(n^2 m)$

Space complexity：

使用滚动数组优化后,
数组 $f[]$ 和 $g[]$ 都是只占用 $(n)$。

所以时间复杂度为：$O(n)$ 。

