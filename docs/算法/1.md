# 第一次作业

孔维飒

## 1.Longest Balanced Substring

Modeling：

题目的输入是一个字符串，输出是最长“平衡”子串的长度。先分析如何计算出一个字符串是否是平衡的，可以使用一个数组记录各字母出现的次数，遍历一次字符串即可检查是否”平衡“，就是说只要得到字符串中各字符出现次数，即可判断是否"平衡"。
然后题目要求是求解最长的子串，最简单的想法是直接暴力二重循环即可。

进一步的发现，如果字符串是不"平衡"的话，导致不"平衡"的字符不可能被包含在任何一个"平衡"子串中，所以可以从不“平衡”的字符位置进行分裂，分成左边后右边两个字符串进行递归计算。

Algorithm：

使用分治算法处理该问题。
处理一个字符串有两种情况：

情况一：当前字符串是“平衡”，那么最大“平衡”子串就是字符串本身。

情况二：当前字符串不"平衡"，那么最大“平衡”子串就在左边字符串和右边字符串中产生，递归计算即可。

Time complexity：

每次递归，都会删除一个字符，所以递归深度最多是 $26$。每一层是 $O(n)$。

总时间复杂度为：$O(26 * n)$。

Space complexity：

递归的深度是 $26$。存储数组本身需要 $O(n)$。

所以空间复杂度为：$O(n)$。

## 2.Cutting Bamboo Poles

Modeling：

题目的输入是 $n$ 个数字，输出是将 $n$ 个数字拆分后包含 $m$ 个相同的数的最大值。记这个 $m$ 个值相同的数为 $x$。
如果可以将 $n$ 个数字拆分出包含 $m$ 个相同的 $x$，那么一定可以拆分出 $m$ 个相同的 $x-1$。
则 $x$ 具有单调性，则可以使用二分算法。

Algorithm：

对求的值进行二分。每次检查只需要检查 $\sum_i \left \lfloor  \frac{l_i}{mid} \right \rfloor \ge m$，如果该式子成立，则 $l = mid$，否则 $r = mid - 1$。
二分的结果就是所求的最大值。

Time complexity：

二分花费 $log(n)$ 次，每次检查花费 $O(n)$ 次。

时间复杂度为：$O(log(n) n)$。

Space complexity：

由于只需要数组存储 $n$ 个数字，所以空间复杂度为：$O(n)$ 。

## 3.Multiple Calculations

Modeling：

题目的输入是一个包含 $+,-,*$ 的表达式，题目输出是随意加括号后表达式所有可能的结果。
根据样例分析，加括号，其实就是改变运算的主运算符。那么在计算时，当选定当前的主运算符，就可以将当前问题分解成两个更短表达式的问题，那么使用分治算法。

Algorithm：

记输入中共有 $n$ 个运算符。

计算一个表达式的所有可能结果，对于每一个运算符都可以作为主运算符(就是表达式中最后一次运算的运算符)，对每一个运算符都分解成该运算符左边表达式和右边的表达式，递归计算左边表达式和右边表达式所有可能结果，对两个结果进行该运算，添加到当前表达式结果中。

伪代码：
```c++
vec dfs(l,r){
  tot_vec = NULL ; // 用来存储当前表达式所有可能结果
  for i in [l..r] :
    vec_1 = dfs(l,i-1) ;
    vec_2 = dfs(i+1,r) ;

    // 将 vec_1 元素 与 vec_2 元素进行 op[i] 运算，结果加入 tot_vec 中
    tot_vec.push(vec_1 op[i] vec_2)

  return tot_vec ;
}
```

Time complexity：

由于每一次选择主运算符，都可以从 $n$ 个中选择一个。

时间复杂度为：$O(n^n)$

Space complexity：

由于 dfs 的深度最深为 $n$ 层，所以空间复杂度为： $O(n)$

## 4.N-sum

Modeling：

题目输入是一个长度为 $n$ 的 $B$ 数组，题目输出是 yes or no。题目需要判断是否存在 $n$ 个下标 $i_1,i_2 ... i_n$，使得式子 $\sum_j B[i_j] = m(m \in [1,n^2])$。

这其实是一个背包问题，不过使用普通的 $dp$　解发时间复杂度过高。

经过分析，可以将构造生成函数 $G(x) = \sum_{i \in B} x^i$，上面的式子 $\sum_j B[i_j]$ 可以转化为 $G(x)^n$。所以求出生成函数的 $n$ 次方即可。

Algorithm：

使用生成函数 $G(x) = \sum_{i \in B} x^i$，使用FFT求出 $G(x)^n = exp(k \space ln f(x))$。
由于题目中 $m \in [1,n^2]$，所以 $G(x) ^ n$ 需要有 $n^2$ 项，则时间复杂度等于 $O(n^2logn)$。

Time complexity：

时间复杂度：$O(n^2logn)$

Space complexity：

由于存储多项式需要 $n^2$。
所以空间复杂度为： $n^2$


## 5.Nnary Cubic Equation

Modeling：

题目的输入是一个一元三次函数的四个系数，输出是这个三次函数的所有根。

题目已经保证在 $[-100,100]$ 范围内有三个实根，并且任意两对根之间差值大于等于一。于是可以推出 $z \in [-100,100]$，则 $[z,z+1]$ 若存在根只能存在一个。那么可以枚举所有长度是1的区间$[l,r]$，如果存在根则可以使用二分进行求解。

Algorithm：

记题目中给出的一元三次函数为 $f(x)$。

从 $-100$ 开始，枚举所有长度为 $1$ 的区间，记为 $[i,i+1]$。如果 $f(i)*f(i+1) \le 0$ 则说明改区间内存在根，使用二分求解；否则该区间无解。

二分过程中，先计算出 $mid = (l + r) / 2$。如果 $f(mid) * f(r) \le 0$，则令 $l = mid$，否则 $r = mid$。

相关伪代码：
```c++
// 如果当前长度为1区间内有解
// 当前区间 l,r
while(fabs(r - l) > eps) {
  double mid = (l + r) / 2 ;

  if(f(mid) * f(r) <= 0) l = mid ;
  else r = mid ;
}
```

Time complexity：

由于需要枚举所有长度为 $1$ 的区间，共有 $200$ 个区间。
对于每个区间，需要执行二分算法，时间复杂度为 $O(log)$。

所以总时间复杂度为：$O(200 * log)$。

Space complexity：

不需要额外空间，所以时间复杂度为：$O(1)$。

## 6.Distance

Modeling：

题目输入为数组 $arr1,arr2$ 和一个整数 $d$，题目输出 "distance value"。

其中"distance value"，就是满足表达式 $\forall j ,\left |  arr1[i] - arr2[j]\right | > d $ 的 $i$ 数量。

化简公式得 $\forall j , arr2[j] < arr1[i] - d$ 或者 $arr2[j] > arr1[i] + d$。

Algorithm：

对数组 $arr2$ 建立权值线段树。然后遍历数组 $arr1$，对于每个元素 $arr1[i]$ 在权值线段树中查询是否存在 $[arr1[i] - d , arr1[i] + d]$ 范围内的数，如果不存在则 $ans ++$。 最后 $ans$ 即为题目要求的 "distance value"。

Time complexity：

记数组最大值为 $N$ 。
对数组 $arr2$ 建立权值线段树，时间复杂度为 $O(nlogN)$。
每次使用权值线段树进行查询花费 $O(logN)$，共查询 $n$ 次，所以花费 $O(nlogN)$。

总时间复杂度为：$O(nlogN)$。

Space complexity：

由于权值线段树花费空间 $4n$。则时间复杂度为：$O(n)$。